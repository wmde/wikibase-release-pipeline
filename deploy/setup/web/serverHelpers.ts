import crypto from 'crypto';
import { existsSync, readFileSync, writeFileSync } from 'fs';

export const ENV_FILE_PATH = '/app/deploy/.env';
export const ENV_TEMPLATE_FILE_PATH = '/app/deploy/template.env';
export const LOG_PATH = '/app/setup.log';

// Status

export function isBooted(): boolean {
	if ( !existsSync( LOG_PATH ) ) {
		return false;
	}
	const log = readFileSync( LOG_PATH, 'utf8' );
	return /Setup is Complete!/i.test( log );
}

export function isConfigSaved(): boolean {
	return existsSync( ENV_FILE_PATH );
}

export function isLocalhostSetup(): boolean {
	return process.env.LOCALHOST === 'true';
}

// Configuration

function parseEnv( content: string ): Record<string, string> {
	const env: Record<string, string> = {};
	for ( const line of content.split( '\n' ) ) {
		const m = line.match( /^([^#=\s]+)=(.*)$/ );
		if ( m ) {
			env[ m[ 1 ] ] = m[ 2 ];
		}
	}
	return env;
}

function getEnv(): Record<string, string> | null {
	if ( !isConfigSaved() ) {
		return null;
	}
	return parseEnv( readFileSync( ENV_FILE_PATH, 'utf8' ) );
}

function getTemplateEnv(): Record<string, string> {
	return parseEnv( readFileSync( ENV_TEMPLATE_FILE_PATH, 'utf8' ) );
}

function hasAnyInput( input: Record<string, string> ): boolean {
	// Any non-empty string counts as “input present”
	return Object.values( input ).some( ( v ) => typeof v === 'string' && v !== '' );
}

const generatePassword = (): string => crypto.randomBytes( 12 ).toString( 'base64' );

function makeConfigText( configObject: Record<string, string> ): string {
	const header = '# Autogenerated from setup UI';
	const lines = Object.entries( configObject ).map( ( [ k, v ] ) => `${ k }=${ v }` );
	return `${ header }\n${ lines.join( '\n' ) }\n`;
}
export function saveConfigText( configText: string ): void {
	return writeFileSync( ENV_FILE_PATH, configText );
}

export function getConfig( input: Record<string, string> = {} ): {
	config: Record<string, string>;
	configText: string;
} {
	// 1) Existing .env wins verbatim
	const existingEnv = getEnv();
	if ( existingEnv ) {
		return { config: existingEnv, configText: makeConfigText( existingEnv ) };
	}

	// 2) User input present → use exactly; passwords autogenerate if blank/missing
	if ( hasAnyInput( input ) ) {
		const configObject: Record<string, string> = {
			...input,
			MW_ADMIN_PASS: input.MW_ADMIN_PASS && input.MW_ADMIN_PASS !== '' ?
				input.MW_ADMIN_PASS : generatePassword(),
			DB_PASS: input.DB_PASS && input.DB_PASS !== '' ?
				input.DB_PASS : generatePassword()
		};

		return { config: configObject, configText: makeConfigText( configObject ) };
	} else {

		// 3) No .env and no input → template + localhost defaults + generated passwords
		const templateEnv = getTemplateEnv();
		const configObject: Record<string, string> = {
			...templateEnv,
			MW_ADMIN_EMAIL: '',
			WIKIBASE_PUBLIC_HOST: isLocalhostSetup() ? 'wikibase.test' : '',
			WDQS_PUBLIC_HOST: isLocalhostSetup() ? 'query.wikibase.test' : '',
			MW_ADMIN_PASS: generatePassword(),
			DB_PASS: generatePassword(),
			METADATA_CALLBACK: 'true'
		};

		return { config: configObject, configText: makeConfigText( configObject ) };
	}
}

export function sanitizeConfig(): void {
	if ( isConfigSaved() ) {
		const { configText } = getConfig();
		// blank password values
		const sanitized = configText.replace( /^(\s*[A-Z0-9_]*PASS(?:WORD)?=).+$/gim, '$1' );
		saveConfigText( sanitized );
		console.log( '🧼 Passwords sanitized' );
	}
}

export function clearLog(): void {
	if ( existsSync( LOG_PATH ) ) {
		writeFileSync( LOG_PATH, '' );
		console.log( '🧹 Log cleared' );
	}
}
