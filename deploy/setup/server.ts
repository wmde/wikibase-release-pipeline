/* eslint-disable n/no-missing-import */
import { writeFile, readFile } from 'fs/promises';
import { existsSync, readFileSync } from 'fs';
import crypto from 'crypto';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';
import https, { request } from 'https';
import express from 'express';
import { Eta } from 'eta';

const fileName = fileURLToPath( import.meta.url );
const dirName = dirname( fileName );

// Constants
const ENV_FILE_PATH = '/app/deploy/.env';
const ENV_TEMPLATE_FILE_PATH = '/app/deploy/template.env';
const LOG_PATH = '/app/setup.log';
const SSL_CERT_KEY_PATH = '/app/certs/key.pem';
const SSL_CERT_PATH = '/app/certs/cert.pem';
// 10 minutes
const AUTO_FINALIZE_TIMEOUT_MS = 10 * 60 * 1000;

// Express setup
const app = express();
app.use( express.static( join( dirName, 'public' ) ) );
app.use( express.json() );

// Eta setup
const eta = new Eta( {
	views: join( dirName, 'views' ),
	cache: false,
	useWith: true
} );

// Helpers
const generatePassword = (): string => crypto.randomBytes( 12 ).toString( 'base64' );

function buildEnvContent( input: Record<string, string> ): {
	config: Record<string, string | boolean>;
	content: string;
} {
	const config = buildConfig( input );
	const content = [
		'# Autogenerated .env file from installer UI',
		...Object.entries( config ).map( ( [ k, v ] ) => `${ k }=${ v }` )
	].join( '\n' ) + '\n';
	return { config, content };
}

function isConfigSaved(): boolean {
	return existsSync( ENV_FILE_PATH );
}

function isBooted(): boolean {
	if ( !existsSync( LOG_PATH ) ) {
		return false;
	}
	const log = readFileSync( LOG_PATH, 'utf8' );
	return log.includes( 'Setup is Complete!' );
}

// Note: Returns a default config when called without input (some transcribe from templat.env)
function buildConfig( input: Record<string, string> = {} ): Record<string, string | boolean> {
	const templateLines = readFileSync( ENV_TEMPLATE_FILE_PATH, 'utf8' ).split( '\n' );
	const templateEnv: Record<string, string> = {};
	for ( const line of templateLines ) {
		const match = line.match( /^([^#=\s]+)=(.*)$/ );
		if ( match ) {
			templateEnv[ match[ 1 ] ] = match[ 2 ];
		}
	}

	return {
		WIKIBASE_PUBLIC_HOST: input.WIKIBASE_PUBLIC_HOST,
		WDQS_PUBLIC_HOST: input.WDQS_PUBLIC_HOST || input.WIKIBASE_PUBLIC_HOST ? `query.${ input.WIKIBASE_PUBLIC_HOST }` : '',
		MW_ADMIN_NAME: input.MW_ADMIN_NAME || templateEnv.MW_ADMIN_NAME,
		MW_ADMIN_EMAIL: input.MW_ADMIN_EMAIL,
		MW_ADMIN_PASS: input.MW_ADMIN_PASS || generatePassword(),
		DB_NAME: input.DB_NAME || templateEnv.DB_NAME,
		DB_USER: input.DB_USER || templateEnv.DB_USER,
		DB_PASS: input.DB_PASS || generatePassword(),
		METADATA_CALLBACK: true
	};
}

function getCurrentConfig(): Record<string, string> {
	if ( !isConfigSaved() ) {
		return {};
	}
	const lines = readFileSync( ENV_FILE_PATH, 'utf8' ).split( '\n' );
	const env: Record<string, string> = {};
	for ( const line of lines ) {
		const match = line.match( /^([^#=\s]+)=(.*)$/ );
		if ( match ) {
			env[ match[ 1 ] ] = match[ 2 ];
		}
	}
	return env;
}

// eslint-disable-next-line @typescript-eslint/explicit-function-return-type
function getStatusPayload() {
	const configSaved = isConfigSaved();
	const booted = isBooted();
	const config = getCurrentConfig();
	return { isConfigSaved: configSaved, isBooted: booted, config };
}

// Routes
app.get( '/', async ( req, res ) => {
	try {
		const config = isConfigSaved() ? getCurrentConfig() : buildConfig();
		const html = eta.render( 'index.eta', {
			...config,
			isConfigSaved: isConfigSaved(),
			isBooted: isBooted(),
			SERVER_IP: process.env.SERVER_IP
		} );
		if ( !html ) {
			throw new Error( 'Eta render returned null' );
		}
		res.type( 'html' ).send( html );
	} catch ( err ) {
		console.error( 'Failed to render template:', err );
		res.status( 500 ).send( 'Template render error' );
	}
} );

app.get( '/log', ( req, res ) => {
	if ( !existsSync( LOG_PATH ) ) {
		return res.status( 404 ).send( 'Log file not found' );
	}
	try {
		const log = readFileSync( LOG_PATH, 'utf8' );
		res.type( 'text/plain' ).send( log );
	} catch ( err ) {
		console.error( 'Failed to read log file:', err );
		res.status( 500 ).send( 'Error reading log file' );
	}
} );

app.get( '/log/stream', ( req, res ) => {
	res.set( {
		'Content-Type': 'text/event-stream',
		'Cache-Control': 'no-cache',
		Connection: 'keep-alive'
	} );
	res.flushHeaders();

	if ( !existsSync( LOG_PATH ) ) {
		res.write( 'data: Log file not found\n\n' );
		res.end();
		return;
	}

	const logStream = readFileSync( LOG_PATH, 'utf8' ).split( '\n' );
	let lastIndex = logStream.length;
	res.write( `data: ${ logStream.slice( -20 ).join( '\n' ) }\n\n` );

	const interval = setInterval( () => {
		if ( !existsSync( LOG_PATH ) ) {
			return;
		}
		const currentLines = readFileSync( LOG_PATH, 'utf8' ).split( '\n' );
		if ( currentLines.length > lastIndex ) {
			res.write( `data: ${ currentLines.slice( lastIndex ).join( '\n' ) }\n\n` );
			lastIndex = currentLines.length;
		}
	}, 1000 );

	req.on( 'close', () => clearInterval( interval ) );
} );

app.get( '/status', ( req, res ) => {
	res.json( getStatusPayload() );
} );

app.get( '/status/stream', ( req, res ) => {
	res.set( {
		'Content-Type': 'text/event-stream',
		'Cache-Control': 'no-cache',
		Connection: 'keep-alive'
	} );
	res.flushHeaders();

	// eslint-disable-next-line @typescript-eslint/explicit-function-return-type
	const sendStatus = () => {
		res.write( `data: ${ JSON.stringify( getStatusPayload() ) }\n\n` );
	};

	sendStatus();
	const interval = setInterval( sendStatus, 2000 );
	req.on( 'close', () => clearInterval( interval ) );
} );

app.post( '/write-env', async ( req, res ): Promise<void> => {
	try {
		const { config, content } = buildEnvContent( req.body );
		await writeFile( ENV_FILE_PATH, content );
		console.log( '.env file written successfully' );
		res.status( 200 ).json( { status: 'ok', generated: config } );
	} catch ( err ) {
		console.error( 'Failed to write .env:', err );
		res.status( 500 ).send( 'Failed to write .env' );
	}
} );

// TODO: Implement call or timer on front-end or here in server to run this
// it should only run when the services have successfully booted, and after
// some timeout period (10 mins?), or when manually initiated from a front end
// user interaction (option not yet added in front end)
app.post( '/finalize-setup', async ( req, res ) => {
	try {
		if ( existsSync( ENV_FILE_PATH ) ) {
			const lines = ( await readFile( ENV_FILE_PATH, 'utf8' ) ).split( '\n' );
			const sanitized = lines.map( ( line ) =>
				line.replace( /^(.*_PASS(?:WORD)?=).+$/, '$1' ) // blank password values
			);
			await writeFile( ENV_FILE_PATH, sanitized.join( '\n' ) );
			console.log( 'üßº Passwords sanitized' );
		}

		if ( existsSync( LOG_PATH ) ) {
			await writeFile( LOG_PATH, '' );
			console.log( 'üßπ Log cleared' );
		}

		res.status( 200 ).json( { status: 'finalized' } );
		console.log( 'üí§ Setup finalized. Exiting...' );
		// eslint-disable-next-line n/no-process-exit
		setTimeout( () => process.exit( 0 ), 300 ); // allow response to finish
	} catch ( err ) {
		console.error( '‚ùå Finalize error:', err );
		res.status( 500 ).send( 'Failed to finalize setup' );
	}
} );

if ( !existsSync( SSL_CERT_PATH ) || !existsSync( SSL_CERT_KEY_PATH ) ) {
	throw new Error( 'Not able to access SSL certificate or key in /app/certs' );
}

const credentials = {
	cert: readFileSync( SSL_CERT_PATH ),
	key: readFileSync( SSL_CERT_KEY_PATH )
};

https.createServer( credentials, app ).listen( 443, () => {
	console.log( '‚úÖ HTTPS server running at https://localhost:443' );
} );

// Kick off finalize if booted and inactive
setTimeout( () => {
	if ( isBooted() ) {
		console.log( '‚è±Ô∏è Auto-finalizing setup after timeout...' );

		const req = request(
			{
				method: 'POST',
				host: 'localhost',
				port: 443,
				path: '/finalize-setup',
				rejectUnauthorized: false, // allow self-signed certs
				headers: {
					'Content-Type': 'application/json'
				}
			},
			( res ) => {
				if ( res.statusCode && res.statusCode >= 200 && res.statusCode < 300 ) {
					console.log( '‚úÖ Auto-finalize complete' );
				} else {
					console.error( `‚ùå Auto-finalize failed: ${ res.statusCode }` );
				}
			}
		);

		req.on( 'error', ( err ) => {
			console.error( '‚ùå Auto-finalize request error:', err );
		} );

		req.end(); // no body needed
	} else {
		console.log( '‚è±Ô∏è Auto-finalize skipped: not yet booted' );
	}
}, AUTO_FINALIZE_TIMEOUT_MS );
